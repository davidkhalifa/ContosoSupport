# Chapter 7: In-Memory Implementation

In the previous chapter, [Cosmos DB Implementation](06_cosmos_db_implementation.md), we learned how to use a database to store our support tickets. This chapter introduces the *in-memory implementation*, a simpler way to store data that's perfect for testing and local development. Think of it like using a whiteboard to keep track of support tickets temporarily â€“ it's easy to use and doesn't require setting up a database.

## What Problem Does the In-Memory Implementation Solve?

Imagine you're building a new feature for `ContosoAdsSupport`, and you want to test it quickly without setting up a complex database. The in-memory implementation allows you to store data in your application's memory, making it fast and convenient for testing and local development.

## Understanding the In-Memory Implementation

The in-memory implementation uses a simple list to store [Support Cases](01_support_case.md).  Instead of saving data to a database, it keeps it in your application's memory, much like writing on a whiteboard.

## Using the In-Memory Implementation

Let's say we want to create a new [Support Case](01_support_case.md) using the in-memory implementation. Here's how we'd do it:

```csharp
// ... assuming supportService is an instance of SupportServiceInMemory

var newCase = new SupportCase { Title = "Login Issue", /* ... other properties */ };
await supportService.CreateAsync(newCase); 
```

This code creates a new `SupportCase` and adds it to the in-memory list.  No database interaction is needed!

Now, let's retrieve this Support Case:

```csharp
var retrievedCase = await supportService.GetAsync(newCase.Id);
// retrievedCase will now contain the Support Case we just created
```

This code retrieves the `SupportCase` from the in-memory list using its `Id`.

## Internal Implementation

`SupportServiceInMemory` (found in `src\ContosoAdsSupport\ContosoSupport\Services\SupportServiceInMemory.cs`) implements the [ISupportService](03_isupportservice.md) interface, just like `SupportServiceCosmosDb`.  However, instead of interacting with a database, it uses a `List<SupportCase>` to store data in memory.

Let's visualize creating a Support Case:

```mermaid
sequenceDiagram
    participant Controller as SupportCasesController
    participant Service as SupportServiceInMemory
    participant Memory as In-Memory List

    Controller->>Service: CreateAsync(newCase)
    activate Service
    Service->>Memory: Add newCase to the list
    deactivate Memory
    Service-->>Controller: Success
    deactivate Service
```

Here's a simplified snippet from `SupportServiceInMemory.CreateAsync`:

```csharp
// ... other code ...

lock (sync) // Ensures thread-safe access to the list
{
    supportCases.Add(supportCase); // Adds the new case to the list
}

// ... other code ...
```

This code adds the `supportCase` to the `supportCases` list.  Similarly, other methods like `GetAsync`, `UpdateAsync`, and `RemoveAsync` operate directly on this in-memory list.

Here's a simplified snippet from `SupportServiceInMemory.GetAsync`:

```csharp
// ... other code ...

SupportCase? result;
lock (sync)
{
    result = supportCases.FirstOrDefault(s => s.Id == id); // Finds the case by ID
}
return Task.FromResult(result); // Returns the found case

// ... other code ...
```

This code searches the `supportCases` list for a `SupportCase` with the matching `Id`.

## Conclusion

We learned that the in-memory implementation provides a simple and efficient way to manage [Support Cases](01_support_case.md) during testing and local development. It avoids the complexities of a database while still adhering to the [ISupportService](03_isupportservice.md) interface.  Next, we'll delve into adding [Telemetry/Instrumentation](08_telemetry_instrumentation.md) to our application.


---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)