# Chapter 8: Telemetry/Instrumentation

In the previous chapter, [In-Memory Implementation](07_in_memory_implementation.md), we explored a simplified way to store data for testing. Now, let's learn how to add *telemetry*, which is like adding sensors to our `ContosoAdsSupport` application. These sensors collect important information about how our application is performing, helping us understand its health and identify potential problems.

## What Problem Does Telemetry Solve?

Imagine our `ContosoAdsSupport` application suddenly becomes slow. How do we figure out what's causing the slowdown? Telemetry provides clues by collecting data like response times, error rates, and resource usage. It's like having a detective inside our application, constantly gathering evidence about its behavior.

## Understanding Telemetry

Telemetry is the process of collecting and transmitting data about our application's performance.  In `ContosoAdsSupport`, we use OpenTelemetry, a powerful tool that helps us gather this information.

We use two key concepts in OpenTelemetry:

* **Tracing:** Imagine following a single support ticket's journey through our application.  Tracing allows us to track each step of this journey, from creation to assignment to resolution. It's like leaving breadcrumbs that show us the path the ticket took.
* **Metrics:**  Metrics are numerical measurements that tell us how our application is doing overall.  For example, we can measure the average time it takes to resolve a support ticket or the number of errors that occurred in the last hour. It's like checking the dashboard of a car to see its speed, fuel level, and engine temperature.

## Using Telemetry

In `ContosoAdsSupport`, the `PerfMetricsMiddleware` class (found in `src\ContosoAdsSupport\ContosoSupport\Middleware\PerfMetricsMiddleware.cs`) is responsible for collecting metrics, such as the time it takes to respond to a request. This data is then sent to a monitoring system for analysis.

Hereâ€™s a simplified snippet illustrating how we record a metric:

```csharp
// ... other code ...

LatencyHistogram.Record(latencyMeasurement, in latencyDimensions);

// ... other code ...
```

This code records the `latencyMeasurement` (the time it took to respond to a request) along with some relevant dimensions (like location, tenant, etc.).

The `Program.cs` file shows how we configure OpenTelemetry to collect this data. It also demonstrates adding custom tracing using `TelemetryHelper`.

```csharp
// ... other code in Program.cs ...

builder.Services.AddOpenTelemetry().WithTracing(options =>
{
    // ... other code ...
    options.AddSource(TelemetryHelper.ActivitySource.Name, "Azure.*"); // Tracing
    // ... other code ...
}).WithMetrics(options =>
{
    // ... other code ...
    options.AddMeter(TelemetryHelper.Meter.Name); // Metrics
    // ... other code ...
});
```

Here, we're telling OpenTelemetry to collect traces from our custom `ActivitySource` (defined in `TelemetryHelper`) and metrics from our custom `Meter`.

## Internal Implementation

Let's visualize how `PerfMetricsMiddleware` collects latency data:

```mermaid
sequenceDiagram
    participant Client
    participant Middleware as PerfMetricsMiddleware
    participant NextMiddleware
    participant OpenTelemetry

    Client->>Middleware: Request
    activate Middleware
    Middleware->>NextMiddleware: Invoke next middleware
    activate NextMiddleware
    NextMiddleware-->>Middleware: Response
    deactivate NextMiddleware
    Middleware->>OpenTelemetry: Record Latency Metric
    deactivate OpenTelemetry
    Middleware-->>Client: Response
    deactivate Middleware
```

When a request comes in, the `PerfMetricsMiddleware` starts a timer.  After the request is processed by subsequent middleware, it stops the timer and records the elapsed time as a latency metric using OpenTelemetry.

Here's a simplified look at the code that measures latency:

```csharp
// In PerfMetricsMiddleware.cs

var timer = Stopwatch.StartNew();
// ... other code ...
timer.Stop();
// ... other code to record the metric using timer.ElapsedMilliseconds ... 
```

This code starts a timer before invoking the next middleware and stops it afterward, capturing the elapsed time between these actions.


## Conclusion

We've learned that telemetry is essential for monitoring the health and performance of our `ContosoAdsSupport` application.  By collecting traces and metrics, we gain valuable insights into how our application behaves and can identify potential problems.  Next, we'll explore the concept of [Middleware](09_middleware.md).


---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)